#!/usr/bin/env python3
"""
Facebook Messenger Automation Bot - Streamlit Cloud Version
"""

import streamlit as st
import json
import time
import threading
import os
import queue # <<< ‡§®‡§Ø‡§æ Import: Queue ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó Thread-Safe Logging ‡§ï‡•á ‡§≤‡§ø‡§è >>>
from datetime import datetime
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.keys import Keys
import subprocess

# ============================================
# PAGE CONFIGURATION
# ============================================
st.set_page_config(
    page_title="FB Messenger Bot", 
    layout="wide",
    initial_sidebar_state="collapsed"
)

# ============================================
# GLOBAL THREAD-SAFE QUEUE
# ============================================
# Logs ‡§ï‡•ã ‡§¨‡•à‡§ï‡§ó‡•ç‡§∞‡§æ‡§â‡§Ç‡§° ‡§•‡•ç‡§∞‡•á‡§° ‡§∏‡•á ‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§•‡•ç‡§∞‡•á‡§° ‡§§‡§ï ‡§™‡§π‡•Å‡§Ç‡§ö‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ó‡•ç‡§≤‡•ã‡§¨‡§≤ ‡§ï‡•ç‡§Ø‡•Ç
LOG_QUEUE = queue.Queue()

# ============================================
# CUSTOM CSS STYLING
# (No changes here, your styling is good)
# ============================================
st.markdown("""
<style>
    .stButton > button {
        background: linear-gradient(90deg, #6B5DD8 0%, #8B7DE8 100%);
        color: white;
        border: none;
        padding: 12px 24px;
        font-size: 16px;
        border-radius: 8px;
        width: 100%;
        font-weight: 500;
        transition: all 0.3s ease;
    }
    .stButton > button:hover {
        background: linear-gradient(90deg, #5B4DC8 0%, #7B6DD8 100%);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(107, 93, 216, 0.3);
    }
    .stButton > button:disabled {
        background: #cccccc;
        cursor: not-allowed;
    }
    .log-container {
        background-color: #1a1a1a;
        color: #00ff00;
        padding: 20px;
        border-radius: 8px;
        font-family: 'Courier New', monospace;
        height: 400px;
        overflow-y: auto;
        margin-top: 20px;
        border: 1px solid #333;
    }
    .log-entry {
        margin: 4px 0;
        font-size: 14px;
        line-height: 1.4;
    }
    h1 {
        color: #6B5DD8;
        text-align: center;
        margin-bottom: 30px;
    }
    .status-running {
        color: #00ff00;
        font-weight: bold;
        font-size: 18px;
    }
    .status-stopped {
        color: #ff4444;
        font-weight: bold;
        font-size: 18px;
    }
    .config-section {
        background-color: #f8f9fa;
        padding: 20px;
        border-radius: 10px;
        margin-bottom: 20px;
        border: 1px solid #e9ecef;
    }
    .port-info {
        background: linear-gradient(90deg, #6B5DD8 0%, #8B7DE8 100%);
        color: white;
        padding: 12px;
        border-radius: 8px;
        text-align: center;
        margin-bottom: 20px;
        font-weight: bold;
        font-size: 16px;
    }
</style>
""", unsafe_allow_html=True)

# ============================================
# SESSION STATE INITIALIZATION
# ============================================
def init_session_state():
    """Initialize all session state variables with default values"""
    if 'logs' not in st.session_state:
        st.session_state.logs = []
    if 'is_running' not in st.session_state:
        st.session_state.is_running = False
    if 'stop_requested' not in st.session_state:
        st.session_state.stop_requested = False
    if 'automation_thread' not in st.session_state:
        st.session_state.automation_thread = None

# Initialize session state at startup
init_session_state()

# ============================================
# HELPER FUNCTIONS
# ============================================

def add_log(message):
    """
    Thread-safe function to add a timestamped log entry.
    It puts the log into a global queue instead of updating st.session_state directly.
    """
    timestamp = datetime.now().strftime("%H:%M:%S")
    log_entry = f"[{timestamp}] AUTO-1: {message}"
    # Log ‡§ï‡•ã ‡§∏‡•Ä‡§ß‡•á st.session_state ‡§Æ‡•á‡§Ç ‡§ú‡•ã‡§°‡§º‡§®‡•á ‡§ï‡•á ‡§¨‡§ú‡§æ‡§Ø Queue ‡§Æ‡•á‡§Ç ‡§°‡§æ‡§≤‡•á‡§Ç
    LOG_QUEUE.put(log_entry)


def process_queue():
    """
    Function to be called by the main Streamlit thread to process 
    logs from the queue and update st.session_state.
    """
    has_new_logs = False
    while not LOG_QUEUE.empty():
        try:
            log_entry = LOG_QUEUE.get_nowait()
            st.session_state.logs.append(log_entry)
            has_new_logs = True
        except queue.Empty:
            break
    
    if len(st.session_state.logs) > 100:
        st.session_state.logs = st.session_state.logs[-100:]
        
    return has_new_logs # ‡§Ö‡§ó‡§∞ ‡§ï‡•ã‡§à ‡§®‡§Ø‡§æ ‡§≤‡•â‡§ó ‡§Ö‡§™‡§°‡•á‡§ü ‡§π‡•Å‡§Ü ‡§π‡•à ‡§§‡•ã True ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§ï‡§∞‡•á‡§Ç


def install_chrome():
    """Install Chrome on Streamlit Cloud"""
    try:
        add_log("üîß Installing Chrome...")
        # ... (Your existing Chrome installation code) ...
        subprocess.run(['apt-get', 'update'], check=True, capture_output=True)
        subprocess.run(['apt-get', 'install', '-y', 'wget'], check=True, capture_output=True)
        subprocess.run([
            'wget', '-q', '-O', '/tmp/google-chrome.pub', 'https://dl-ssl.google.com/linux/linux_signing_key.pub'
        ], check=True, capture_output=True)
        subprocess.run([
            'wget', 'https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb'
        ], check=True, capture_output=True)
        subprocess.run([
            'dpkg', '-i', './google-chrome-stable_current_amd64.deb'
        ], check=False, capture_output=True) 
        subprocess.run(['apt-get', 'install', '-f', '-y'], check=False, capture_output=True)

        add_log("‚úÖ Chrome installed successfully (or installation attempted)!")
        return True
    except Exception as e:
        add_log(f"‚ùå Chrome installation failed: {str(e)}")
        return False

def setup_chrome_driver():
    """Setup Chrome driver for Streamlit Cloud"""
    try:
        chrome_options = Options()
        chrome_options.add_argument('--headless=new')
        chrome_options.add_argument('--no-sandbox')
        chrome_options.add_argument('--disable-dev-shm-usage')
        chrome_options.add_argument('--disable-gpu')
        chrome_options.add_argument('--disable-blink-features=AutomationControlled')
        chrome_options.add_argument('--window-size=1920,1080')
        chrome_options.add_argument('--user-agent=Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36')
        
        chrome_options.binary_location = '/usr/bin/google-chrome'
        
        driver_path = '/usr/bin/chromedriver'
        if not os.path.exists(driver_path):
             add_log("‚ö†Ô∏è ChromeDriver not found at default location. Trying webdriver-manager...")
             from webdriver_manager.chrome import ChromeDriverManager
             from selenium.webdriver.chrome.service import Service as ChromeService
             service = ChromeService(ChromeDriverManager().install())
        else:
             service = Service(executable_path=driver_path)

        driver = webdriver.Chrome(service=service, options=chrome_options)
        driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
        
        add_log("‚úÖ ChromeDriver setup completed!")
        return driver
        
    except Exception as e:
        add_log(f"‚ùå ChromeDriver setup failed: {str(e)}")
        return None

def parse_cookies(cookie_string):
    """Parse cookies from various formats"""
    # (Your existing cookie parsing function)
    cookies = []
    try:
        # Try JSON format first
        if cookie_string.strip().startswith('[') or cookie_string.strip().startswith('{'):
            cookie_data = json.loads(cookie_string)
            return cookie_data if isinstance(cookie_data, list) else [cookie_data]
        
        # Parse different delimited formats
        cookie_pairs = []
        if ';' in cookie_string:
            cookie_pairs = cookie_string.split(';')
        elif '\n' in cookie_string or '\r' in cookie_string:
            cookie_pairs = cookie_string.replace('\r\n', '\n').split('\n')
        elif ',' in cookie_string and '=' in cookie_string:
            cookie_pairs = cookie_string.split(',')
        else:
            cookie_pairs = [cookie_string]
        
        for pair in cookie_pairs:
            pair = pair.strip()
            if '=' in pair and pair:
                key, value = pair.split('=', 1)
                cookies.append({
                    'name': key.strip(), 
                    'value': value.strip(), 
                    'domain': '.facebook.com'
                })
        return cookies
    except Exception as e:
        add_log(f"‚ùå Cookie parsing error: {str(e)}")
        return []

# ============================================
# AUTOMATION FUNCTION (Runs in background thread)
# ============================================

def run_automation(cookies_str, messages, thread_id, delay):
    """
    Main automation function.
    This runs inside a separate thread, so it MUST NOT directly call st.session_state.
    """
    # Note: st.session_state.stop_requested ‡§ï‡•ã ‡§á‡§∏ ‡§•‡•ç‡§∞‡•á‡§° ‡§ï‡•á ‡§Ö‡§Ç‡§¶‡§∞ ‡§∏‡•á ‡§∏‡•Å‡§∞‡§ï‡•ç‡§∑‡§ø‡§§ ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§™‡§¢‡§º‡§æ ‡§ú‡§æ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à
    is_stop_requested = False
    
    driver = None
    try:
        add_log("üöÄ Starting automation...")
        add_log("‚öôÔ∏è Setting up Chrome browser...")
        
        # Check for stop request (Reading is generally safe)
        if st.session_state.stop_requested:
            add_log("‚èπÔ∏è Automation cancelled before start by user.")
            return

        # Install Chrome if needed
        if not os.path.exists('/usr/bin/google-chrome'):
            if not install_chrome():
                add_log("‚ùå Chrome installation required but failed")
                return
        
        driver = setup_chrome_driver()
        if not driver:
            add_log("‚ùå Chrome setup failed")
            return
            
        add_log("‚úÖ Chrome setup completed!")
        
        # ... (Rest of your Selenium logic) ...

        add_log("üåê Navigating to Facebook...")
        driver.get("https://www.facebook.com")
        time.sleep(3)
        
        add_log(f"üìÑ Page loaded: {driver.title[:50]}")
        
        # Parse and add cookies
        cookies = parse_cookies(cookies_str)
        if not cookies:
            add_log("‚ùå Failed to parse cookies")
            return
        
        add_log(f"üç™ Adding {len(cookies)} cookies...")
        for cookie in cookies:
            try:
                driver.add_cookie(cookie)
                add_log(f"‚úÖ Cookie: {cookie['name'][:20]}")
            except Exception as e:
                add_log(f"‚ö†Ô∏è Cookie failed: {cookie.get('name', 'unknown')}")
        
        # Navigate to conversation
        thread_url = f"https://www.facebook.com/messages/t/{thread_id}"
        add_log(f"üí¨ Opening conversation: {thread_id}")
        driver.get(thread_url)
        time.sleep(5)
        
        add_log(f"üîó URL: {driver.current_url}")
        
        # Process messages
        message_list = [msg.strip() for msg in messages.split('\n') if msg.strip()]
        add_log(f"üìù Messages to send: {len(message_list)}")
        
        selectors = [
            'div[contenteditable="true"][role="textbox"]',
            'div[aria-label*="message" i][contenteditable="true"]',
            'div[data-lexical-editor="true"]',
            'div.notranslate[contenteditable="true"]',
            'div[contenteditable="true"]',
            'textarea[placeholder*="message" i]',
            'div[role="textbox"]',
            'div[aria-label*="Type a message" i]'
        ]
        
        for idx, message in enumerate(message_list, 1):
            # Reading stop_requested inside the thread
            if st.session_state.stop_requested:
                add_log("‚èπÔ∏è Stopped by user")
                is_stop_requested = True
                break
            
            try:
                add_log(f"üéØ Message {idx}/{len(message_list)}")
                
                # Find message input
                message_input = None
                for sel_idx, selector in enumerate(selectors, 1):
                    try:
                        elements = driver.find_elements(By.CSS_SELECTOR, selector)
                        if elements:
                            add_log(f'‚úÖ Selector {sel_idx}: {len(elements)} found')
                            message_input = elements[0]
                            break
                    except:
                        continue
                
                if not message_input:
                    add_log("‚ùå Message input not found")
                    continue
                
                # Type message
                add_log(f"‚å®Ô∏è Typing: {message[:50]}...")
                message_input.click()
                time.sleep(1)
                
                # Clear existing
                message_input.send_keys(Keys.CONTROL + "a")
                time.sleep(0.5)
                message_input.send_keys(Keys.DELETE)
                time.sleep(0.5)
                
                # Type new message
                message_input.send_keys(message)
                time.sleep(1)
                
                # Send
                add_log("üì§ Sending...")
                message_input.send_keys(Keys.RETURN)
                
                add_log(f"‚úÖ Message {idx} sent!")
                time.sleep(delay)
                
            except Exception as e:
                add_log(f"‚ùå Error: {str(e)[:100]}")
                time.sleep(2)
                continue
        
        if not is_stop_requested:
            add_log("üéâ Automation completed!")
        
    except Exception as e:
        add_log(f"‚ùå Critical error: {str(e)[:100]}")
    
    finally:
        if driver:
            try:
                driver.quit()
                add_log("üîí Browser closed")
            except:
                pass
        
        # Automation ‡§ñ‡§§‡•ç‡§Æ ‡§π‡•ã‡§®‡•á ‡§™‡§∞ ‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§•‡•ç‡§∞‡•á‡§° ‡§ï‡•ã ‡§∏‡•Ç‡§ö‡§ø‡§§ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è Queue ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§Ö‡§Ç‡§§‡§ø‡§Æ ‡§≤‡•â‡§ó ‡§°‡§æ‡§≤‡•á‡§Ç 
        # ‡§î‡§∞ ‡§è‡§ï ‡§∏‡•ç‡§ü‡•â‡§™ ‡§´‡•ç‡§≤‡•à‡§ó ‡§ï‡•ã ‡§Ö‡§™‡§°‡•á‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§
        # Note: ‡§á‡§∏ ‡§ú‡§ó‡§π ‡§™‡§∞ ‡§π‡§Æ st.session_state ‡§ï‡•ã ‡§Ö‡§™‡§°‡•á‡§ü ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á, ‡§á‡§∏‡§≤‡§ø‡§è ‡§π‡§Æ ‡§á‡§∏‡•á main() ‡§Æ‡•á‡§Ç ‡§π‡•à‡§Ç‡§°‡§≤ ‡§ï‡§∞‡•á‡§Ç‡§ó‡•á
        LOG_QUEUE.put("---THREAD_FINISHED---") 


def start_automation_thread(cookies, messages, thread_id, delay):
    """Start automation in background thread"""
    def wrapper():
        # run_automation ‡§ï‡•ã ‡§ï‡•â‡§≤ ‡§ï‡§∞‡•á‡§Ç
        run_automation(cookies, messages, thread_id, delay)
    
    # automation ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•ã‡§®‡•á ‡§∏‡•á ‡§™‡§π‡§≤‡•á ‡§π‡•Ä UI state ‡§ï‡•ã ‡§Ö‡§™‡§°‡•á‡§ü ‡§ï‡§∞‡•á‡§Ç
    st.session_state.is_running = True 
    st.session_state.stop_requested = False
    
    thread = threading.Thread(target=wrapper, daemon=True)
    thread.start()
    st.session_state.automation_thread = thread
    
    # thread ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§¨‡§æ‡§¶ ‡§π‡•Ä UI ‡§ï‡•ã ‡§Ö‡§™‡§°‡•á‡§ü ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è rerun ‡§ï‡§∞‡•á‡§Ç
    st.experimental_rerun() 

# ============================================
# MAIN UI
# ============================================

def main():
    
    # üìå ‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§¨‡§¶‡§≤‡§æ‡§µ: ‡§π‡§∞ ‡§¨‡§æ‡§∞ ‡§∞‡•Ä-‡§∞‡§® ‡§π‡•ã‡§®‡•á ‡§™‡§∞ ‡§≤‡•â‡§ó ‡§ï‡•ç‡§Ø‡•Ç ‡§ï‡•ã ‡§™‡•ç‡§∞‡•ã‡§∏‡•á‡§∏ ‡§ï‡§∞‡•á‡§Ç
    # ‡§Ø‡§π ‡§∏‡•Å‡§®‡§ø‡§∂‡•ç‡§ö‡§ø‡§§ ‡§ï‡§∞‡§§‡§æ ‡§π‡•à ‡§ï‡§ø ‡§¨‡•à‡§ï‡§ó‡•ç‡§∞‡§æ‡§â‡§Ç‡§° ‡§•‡•ç‡§∞‡•á‡§° ‡§ï‡•á Logs main thread ‡§Æ‡•á‡§Ç ‡§Ü ‡§ú‡§æ‡§è‡§Ç‡•§
    rerun_needed = process_queue()
    
    # ‡§Ö‡§ó‡§∞ ‡§•‡•ç‡§∞‡•á‡§° ‡§ñ‡§§‡•ç‡§Æ ‡§π‡•ã ‡§ó‡§Ø‡§æ ‡§π‡•à ‡§î‡§∞ logs ‡§Æ‡•á‡§Ç ‡§Ö‡§Ç‡§§‡§ø‡§Æ ‡§´‡•ç‡§≤‡•à‡§ó ‡§π‡•à, ‡§§‡•ã state ‡§ï‡•ã ‡§Ö‡§™‡§°‡•á‡§ü ‡§ï‡§∞‡•á‡§Ç
    if st.session_state.logs and st.session_state.logs[-1] == "---THREAD_FINISHED---":
        st.session_state.logs.pop() # ‡§´‡•ç‡§≤‡•à‡§ó ‡§ï‡•ã ‡§π‡§ü‡§æ ‡§¶‡•á‡§Ç
        st.session_state.is_running = False # Automation ‡§ñ‡§§‡•ç‡§Æ ‡§π‡•ã ‡§ó‡§Ø‡§æ
        st.experimental_rerun() # UI ‡§ï‡•ã ‡§Ö‡§Ç‡§§‡§ø‡§Æ ‡§¨‡§æ‡§∞ ‡§Ö‡§™‡§°‡•á‡§ü ‡§ï‡§∞‡•á‡§Ç
        return # main ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§∏‡•á ‡§¨‡§æ‡§π‡§∞ ‡§®‡§ø‡§ï‡§≤ ‡§ú‡§æ‡§è‡§Ç
        
    
    st.title("ü§ñ Facebook Messenger Automation Bot")
    
    # Status display
    col1, col2 = st.columns(2)
    with col1:
        if st.session_state.is_running:
            st.markdown('<p class="status-running">üü¢ RUNNING</p>', unsafe_allow_html=True)
        else:
            st.markdown('<p class="status-stopped">üî¥ STOPPED</p>', unsafe_allow_html=True)
    
    with col2:
        if st.session_state.is_running:
            if st.button("‚èπÔ∏è Stop Bot", key="stop_btn"):
                st.session_state.stop_requested = True
                # Log ‡§∏‡•Ä‡§ß‡•á ‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§•‡•ç‡§∞‡•á‡§° ‡§∏‡•á ‡§ú‡•ã‡§°‡§º‡•á‡§Ç
                st.session_state.logs.append(f"[{datetime.now().strftime('%H:%M:%S')}] AUTO-1: üõë Stop requested") 
                st.experimental_rerun() # ‡§∏‡•ç‡§ü‡•â‡§™ ‡§∞‡§ø‡§ï‡•ç‡§µ‡•á‡§∏‡•ç‡§ü ‡§ï‡•á ‡§¨‡§æ‡§¶ UI ‡§ï‡•ã ‡§Ö‡§™‡§°‡•á‡§ü ‡§ï‡§∞‡•á‡§Ç
    
    # Configuration
    st.markdown('<div class="config-section">', unsafe_allow_html=True)
    st.subheader("‚öôÔ∏è Configuration")
    
    col1, col2 = st.columns(2)
    
    with col1:
        thread_id = st.text_input(
            "üí¨ Thread ID", 
            placeholder="1234567890",
            help="Find in URL: /messages/t/[THREAD_ID]",
            key="thread_id" 
        )
        
        delay = st.number_input(
            "‚è∞ Delay (seconds)", 
            min_value=1, 
            max_value=60, 
            value=3,
            key="delay" 
        )
    
    with col2:
        messages = st.text_area(
            "üìù Messages (one per line)",
            height=150,
            placeholder="Hello!\nHow are you?\nAutomated message",
            key="messages_input"
        )
    
    # Cookies (full width)
    cookies = st.text_area(
        "üç™ Facebook Cookies (All Formats Supported)", 
        height=100,
        placeholder="JSON: [{\"name\":\"c_user\",\"value\":\"123\",...}]\nSemicolon: c_user=123; xs=abc\nNewline: one per line",
        help="Supports: JSON, semicolon-delimited, newline-separated",
        key="cookies_input" 
    )
    
    st.markdown('</div>', unsafe_allow_html=True)
    
    # Start button
    if not st.session_state.is_running:
        if st.button("üöÄ Start Automation", key="start_btn"):
            if not thread_id:
                st.error("‚ùå Enter Thread ID")
            elif not messages.strip():
                st.error("‚ùå Enter Messages")
            elif not cookies.strip():
                st.error("‚ùå Enter Cookies")
            else:
                # Log ‡§∏‡•Ä‡§ß‡•á ‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§•‡•ç‡§∞‡•á‡§° ‡§∏‡•á ‡§ú‡•ã‡§°‡§º‡•á‡§Ç
                st.session_state.logs.append(f"[{datetime.now().strftime('%H:%M:%S')}] AUTO-1: üé¨ Starting...")
                start_automation_thread(cookies, messages, thread_id, delay)
    
    # Logs
    st.subheader("üìä Live Logs")
    
    # üìå ‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§¨‡§¶‡§≤‡§æ‡§µ: Logs ‡§ï‡•ã Live ‡§Ö‡§™‡§°‡•á‡§ü ‡§ï‡§∞‡§®‡•á ‡§ï‡§æ ‡§≤‡•â‡§ú‡§ø‡§ï
    if st.session_state.is_running:
        # ‡§Ö‡§ó‡§∞ automation ‡§ö‡§≤ ‡§∞‡§π‡§æ ‡§π‡•à, ‡§§‡•ã logs ‡§ï‡•ã ‡§≤‡§ó‡§æ‡§§‡§æ‡§∞ ‡§Ö‡§™‡§°‡•á‡§ü ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§π‡§∞ 1 ‡§∏‡•á‡§ï‡§Ç‡§° ‡§Æ‡•á‡§Ç ‡§∞‡•Ä-‡§∞‡§® ‡§ï‡§∞‡•á‡§Ç
        time.sleep(1)
        st.experimental_rerun()
    elif rerun_needed:
         # ‡§Ö‡§ó‡§∞ automation ‡§®‡§π‡•Ä‡§Ç ‡§ö‡§≤ ‡§∞‡§π‡§æ ‡§π‡•à, ‡§≤‡•á‡§ï‡§ø‡§® queue ‡§Æ‡•á‡§Ç logs ‡§•‡•á, ‡§§‡•ã UI ‡§ï‡•ã ‡§è‡§ï ‡§¨‡§æ‡§∞ ‡§Ö‡§™‡§°‡•á‡§ü ‡§ï‡§∞‡•á‡§Ç
         st.experimental_rerun()

    
    if st.session_state.logs:
        log_html = '<div class="log-container">'
        # logs ‡§ï‡•ã UI ‡§Æ‡•á‡§Ç ‡§¶‡§ø‡§ñ‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è
        for log in reversed(st.session_state.logs[-50:]):
            log_html += f'<div class="log-entry">{log}</div>'
        log_html += '</div>'
        st.markdown(log_html, unsafe_allow_html=True)
    else:
        st.info("üìù Logs will appear here...")
    
    # Clear logs
    if st.session_state.logs:
        if st.button("üóëÔ∏è Clear Logs"):
            st.session_state.logs = []
            st.experimental_rerun()
    
    # Instructions (No changes here)
    with st.expander("üìñ Instructions"):
        st.markdown("""
        ### How to Use:
        
        1. **Get Cookies:**
           - Login to Facebook
           - F12 > Application > Cookies > facebook.com
           - Copy all cookies
        
        2. **Find Thread ID:**
           - Open Messenger conversation
           - Copy ID from URL: `/messages/t/[ID]`
        
        3. **Configure:**
           - Paste cookies (any format)
           - Enter messages (one per line)
           - Set delay (3-5 sec recommended)
        
        4. **Start:**
           - Click "Start Automation"
           - Monitor logs
        
        ### Supported Cookie Formats:
        - **JSON:** `[{"name":"c_user","value":"123","domain":".facebook.com"}]`
        - **Semicolon:** `c_user=123; xs=abc; datr=xyz`
        - **Newline:** One cookie per line
        
        ### Note:
        First run may take longer as Chrome gets installed automatically.
        """)

if __name__ == "__main__":
    main()
